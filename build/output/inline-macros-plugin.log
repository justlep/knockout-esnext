
Running Rollup inline-macros plugin
for Knockout JavaScript library v3.5.1-mod26-esnext


------- src/binding/bindingAttributeSyntax.js --------

[bindingAttributeSyntax.js:37]
Found local macro: "_getBindingInfoForNode"

[bindingAttributeSyntax.js:38]
Found local macro: "_ensureNodeHasDomData"

[bindingAttributeSyntax.js:39]
Found local macro: "_getOrAddBindingInfoInDomData"

[bindingAttributeSyntax.js:549]
Found local macro: "_getBindingContext"  (MULTI-LINE-EXPRESSION)

[bindingAttributeSyntax.js:188]
Inlined: "_getBindingInfoForNode"
OLD:  let bindingInfo = _getBindingInfoForNode(node),
NEW:  let bindingInfo = (node[DOM_DATASTORE_PROP] && node[DOM_DATASTORE_PROP][BINDING_INFO_DOM_DATA_KEY]),

[bindingAttributeSyntax.js:252]
Inlined: "_ensureNodeHasDomData"
OLD:  _ensureNodeHasDomData(node);
NEW:  (node[DOM_DATASTORE_PROP] || (node[DOM_DATASTORE_PROP] = {}));

[bindingAttributeSyntax.js:253]
Inlined: "_ensureNodeHasDomData"
OLD:  let nodeDomData = _ensureNodeHasDomData(node),
NEW:  let nodeDomData = (node[DOM_DATASTORE_PROP] || (node[DOM_DATASTORE_PROP] = {})),

[bindingAttributeSyntax.js:254]
Inlined: "_getOrAddBindingInfoInDomData"
OLD:  bindingInfo = _getOrAddBindingInfoInDomData(nodeDomData),
NEW:  bindingInfo = (nodeDomData[BINDING_INFO_DOM_DATA_KEY] || (nodeDomData[BINDING_INFO_DOM_DATA_KEY] = {})),

[bindingAttributeSyntax.js:264]
Inlined: "_getBindingInfoForNode"
OLD:  let bindingInfo = _getBindingInfoForNode(node);
NEW:  let bindingInfo = (node[DOM_DATASTORE_PROP] && node[DOM_DATASTORE_PROP][BINDING_INFO_DOM_DATA_KEY]);

[bindingAttributeSyntax.js:277]
Inlined: "hasSubscriptionsForEvent" (global macro)
OLD:  } else if (_asyncContext === undefined && _eventSubscribable && hasSubscriptionsForEvent(_eventSubscribable, EVENT_DESCENDENTS_COMPLETE)) {
NEW:  } else if (_asyncContext === undefined && _eventSubscribable && ((_eventSubscribable._subscriptions[EVENT_DESCENDENTS_COMPLETE] || 0).length)) {

[bindingAttributeSyntax.js:286]
Inlined: "_ensureNodeHasDomData"
OLD:  let nodeDomData = _ensureNodeHasDomData(node),
NEW:  let nodeDomData = (node[DOM_DATASTORE_PROP] || (node[DOM_DATASTORE_PROP] = {})),

[bindingAttributeSyntax.js:287]
Inlined: "_getOrAddBindingInfoInDomData"
OLD:  bindingInfo = _getOrAddBindingInfoInDomData(nodeDomData);
NEW:  bindingInfo = (nodeDomData[BINDING_INFO_DOM_DATA_KEY] || (nodeDomData[BINDING_INFO_DOM_DATA_KEY] = {}));

[bindingAttributeSyntax.js:363]
Inlined: "_ensureNodeHasDomData"
OLD:  let nodeDomData = _ensureNodeHasDomData(node),
NEW:  let nodeDomData = (node[DOM_DATASTORE_PROP] || (node[DOM_DATASTORE_PROP] = {})),

[bindingAttributeSyntax.js:364]
Inlined: "_getOrAddBindingInfoInDomData"
OLD:  bindingInfo = _getOrAddBindingInfoInDomData(nodeDomData);
NEW:  bindingInfo = (nodeDomData[BINDING_INFO_DOM_DATA_KEY] || (nodeDomData[BINDING_INFO_DOM_DATA_KEY] = {}));

[bindingAttributeSyntax.js:450]
Inlined: "childNodes" (global macro)
OLD:  let nodes = childNodes(node);
NEW:  let nodes = (_isStartComment(node) ? _getVirtualChildren(node) : node.childNodes);

[bindingAttributeSyntax.js:1]
Added dependency-import "START_COMMENT_REGEX" for macro "childNodes"
OLD:  import {childNodes, nextSibling, firstChild, allowedVirtualElementBindings} from '../virtualElements';
NEW:  import {childNodes, START_COMMENT_REGEX, nextSibling, firstChild, allowedVirtualElementBindings} from '../virtualElements';

[bindingAttributeSyntax.js:1]
Added dependency-import "_getVirtualChildren" for macro "childNodes"
OLD:  import {childNodes, START_COMMENT_REGEX, nextSibling, firstChild, allowedVirtualElementBindings} from '../virtualElements';
NEW:  import {childNodes, _getVirtualChildren, START_COMMENT_REGEX, nextSibling, firstChild, allowedVirtualElementBindings} from '../virtualElements';

[bindingAttributeSyntax.js:450]
Inlined: "_isStartComment"  [iteration #2] (global macro)
OLD:  let nodes = childNodes(node);
NEW:  let nodes = (((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue)) ? _getVirtualChildren(node) : node.childNodes);

Skipped adding dependency import - some import like {START_COMMENT_REGEX} from 'virtualElements' already exists in bindingAttributeSyntax.js

[bindingAttributeSyntax.js:554]
Inlined: "_getBindingContext"
OLD:  return _applyBindingsToNodeInternal(node, bindings, _getBindingContext(viewModelOrBindingContext, undefined));
NEW:  return _applyBindingsToNodeInternal(node, bindings, ( (viewModelOrBindingContext && viewModelOrBindingContext[IS_BINDING_CONTEXT_INSTANCE]) ? viewModelOrBindingContext : new KoBindingContext(viewModelOrBindingContext, undefined, undefined, undefined)));

[bindingAttributeSyntax.js:558]
Inlined: "_getBindingContext"
OLD:  let context = _getBindingContext(viewModelOrBindingContext, undefined),
NEW:  let context = ( (viewModelOrBindingContext && viewModelOrBindingContext[IS_BINDING_CONTEXT_INSTANCE]) ? viewModelOrBindingContext : new KoBindingContext(viewModelOrBindingContext, undefined, undefined, undefined)),

[bindingAttributeSyntax.js:576]
Inlined: "_getBindingContext"
OLD:  _applyBindingsToDescendantsInternal(_getBindingContext(viewModelOrBindingContext, undefined), rootNode);
NEW:  _applyBindingsToDescendantsInternal(( (viewModelOrBindingContext && viewModelOrBindingContext[IS_BINDING_CONTEXT_INSTANCE]) ? viewModelOrBindingContext : new KoBindingContext(viewModelOrBindingContext, undefined, undefined, undefined)), rootNode);

[bindingAttributeSyntax.js:589]
Inlined: "_getBindingContext"
OLD:  _applyBindingsToNodeAndDescendantsInternal(_getBindingContext(viewModelOrBindingContext, extendContextCallback), rootNode);
NEW:  _applyBindingsToNodeAndDescendantsInternal(( (viewModelOrBindingContext && viewModelOrBindingContext[IS_BINDING_CONTEXT_INSTANCE]) ? viewModelOrBindingContext : new KoBindingContext(viewModelOrBindingContext, undefined, undefined, extendContextCallback)), rootNode);

[bindingAttributeSyntax.js:595]
Inlined: "_getBindingInfoForNode"
OLD:  let bindingInfo =  node && _getBindingInfoForNode(node);
NEW:  let bindingInfo =  node && (node[DOM_DATASTORE_PROP] && node[DOM_DATASTORE_PROP][BINDING_INFO_DOM_DATA_KEY]);

[bindingAttributeSyntax.js:602]
Inlined: "_getBindingInfoForNode"
OLD:  let bindingInfo = node && (node.nodeType === 1 || node.nodeType === 8) && _getBindingInfoForNode(node),
NEW:  let bindingInfo = node && (node.nodeType === 1 || node.nodeType === 8) && (node[DOM_DATASTORE_PROP] && node[DOM_DATASTORE_PROP][BINDING_INFO_DOM_DATA_KEY]),


------- src/binding/bindingProvider.js --------

[bindingProvider.js:7]
Found local macro: "virtualNodeBindingValue"

[bindingProvider.js:16]
Found local macro: "_getBindingsString"

[bindingProvider.js:45]
Inlined: "_getBindingsString"
OLD:  let bindingsString = _getBindingsString(node),
NEW:  let bindingsString = (node.nodeType === 1 ? node.getAttribute(DEFAULT_BINDING_ATTRIBUTE_NAME) : node.nodeType === 8 ? virtualNodeBindingValue(node) : null),

[bindingProvider.js:45]
Inlined: "virtualNodeBindingValue"  [iteration #2]
OLD:  let bindingsString = _getBindingsString(node),
NEW:  let bindingsString = (node.nodeType === 1 ? node.getAttribute(DEFAULT_BINDING_ATTRIBUTE_NAME) : node.nodeType === 8 ? (START_COMMENT_REGEX.test(node.nodeValue) ? RegExp.$1 : null) : null),

[bindingProvider.js:51]
Inlined: "_getBindingsString"
OLD:  let bindingsString = _getBindingsString(node),
NEW:  let bindingsString = (node.nodeType === 1 ? node.getAttribute(DEFAULT_BINDING_ATTRIBUTE_NAME) : node.nodeType === 8 ? virtualNodeBindingValue(node) : null),

[bindingProvider.js:51]
Inlined: "virtualNodeBindingValue"  [iteration #2]
OLD:  let bindingsString = _getBindingsString(node),
NEW:  let bindingsString = (node.nodeType === 1 ? node.getAttribute(DEFAULT_BINDING_ATTRIBUTE_NAME) : node.nodeType === 8 ? (START_COMMENT_REGEX.test(node.nodeValue) ? RegExp.$1 : null) : null),

[ifIfnotWith.js:74]
Inlined: "childNodes" (global macro)
OLD:  savedNodes = cloneNodes(childNodes(element), true /* shouldCleanNodes */);
NEW:  savedNodes = cloneNodes((_isStartComment(element) ? _getVirtualChildren(element) : element.childNodes), true /* shouldCleanNodes */);

[ifIfnotWith.js:4]
Added dependency-import "START_COMMENT_REGEX" for macro "childNodes"
OLD:  import {childNodes, setDomNodeChildren, allowedVirtualElementBindings, emptyNode} from '../../virtualElements';
NEW:  import {childNodes, START_COMMENT_REGEX, setDomNodeChildren, allowedVirtualElementBindings, emptyNode} from '../../virtualElements';

[ifIfnotWith.js:4]
Added dependency-import "_getVirtualChildren" for macro "childNodes"
OLD:  import {childNodes, START_COMMENT_REGEX, setDomNodeChildren, allowedVirtualElementBindings, emptyNode} from '../../virtualElements';
NEW:  import {childNodes, _getVirtualChildren, START_COMMENT_REGEX, setDomNodeChildren, allowedVirtualElementBindings, emptyNode} from '../../virtualElements';

[ifIfnotWith.js:74]
Inlined: "_isStartComment"  [iteration #2] (global macro)
OLD:  savedNodes = cloneNodes(childNodes(element), true /* shouldCleanNodes */);
NEW:  savedNodes = cloneNodes((((element.nodeType === 8) && START_COMMENT_REGEX.test(element.nodeValue)) ? _getVirtualChildren(element) : element.childNodes), true /* shouldCleanNodes */);

Skipped adding dependency import - some import like {START_COMMENT_REGEX} from 'virtualElements' already exists in ifIfnotWith.js

[arrayToDomNodeChildren.js:63]
Inlined: "getDomData" (global macro)
OLD:  let lastMappingResult = getDomData(domNode, LAST_MAPPING_RESULT_DOM_DATA_KEY);
NEW:  let lastMappingResult = (domNode[DOM_DATASTORE_PROP] && domNode[DOM_DATASTORE_PROP][LAST_MAPPING_RESULT_DOM_DATA_KEY]);

[arrayToDomNodeChildren.js:1]
Added dependency-import "DOM_DATASTORE_PROP" for macro "getDomData"
OLD:  import {nextDomDataKey, getDomData, setDomData} from '../../utils.domData';
NEW:  import {nextDomDataKey, getDomData, DOM_DATASTORE_PROP, setDomData} from '../../utils.domData';

[arrayToDomNodeChildren.js:93]
Inlined: "peekObservableInternal" (global macro)
OLD:  if (currentArrayIndex !== peekObservableInternal(_indexObservable)) {
NEW:  if (currentArrayIndex !== (_indexObservable[LATEST_VALUE_KEY])) {

[arrayToDomNodeChildren.js:2]
Added dependency-import "LATEST_VALUE_KEY" for macro "peekObservableInternal"
OLD:  import {observable, peekObservableInternal} from '../../subscribables/observable';
NEW:  import {observable, peekObservableInternal, LATEST_VALUE_KEY} from '../../subscribables/observable';

[arrayToDomNodeChildren.js:190]
Inlined: "removeNode" (global macro)
OLD:  // TODO modify so that removeNode() becomes an explicit invocation which can be inlined (removeNode = global macro)
NEW:  // TODO modify so that (cleanNode().remove()) becomes an explicit invocation which can be inlined (removeNode = global macro)

Skipped adding macro-dependency cleanNode (already imported)

[selectExtensions.js:11]
Inlined: "getDomData" (global macro)
OLD:  return element[HAS_DOM_DATA_EXPANDO_PROPERTY] ? getDomData(element, OPTION_VALUE_DOM_DATA_KEY) : element.value;
NEW:  return element[HAS_DOM_DATA_EXPANDO_PROPERTY] ? (element[DOM_DATASTORE_PROP] && element[DOM_DATASTORE_PROP][OPTION_VALUE_DOM_DATA_KEY]) : element.value;

[selectExtensions.js:1]
Added dependency-import "DOM_DATASTORE_PROP" for macro "getDomData"
OLD:  import {getDomData, setDomData, nextDomDataKey} from '../utils.domData';
NEW:  import {getDomData, DOM_DATASTORE_PROP, setDomData, nextDomDataKey} from '../utils.domData';

[componentBinding.js:32]
Inlined: "childNodes" (global macro)
OLD:  originalChildNodes = Array.from(childNodes(element));
NEW:  originalChildNodes = Array.from((_isStartComment(element) ? _getVirtualChildren(element) : element.childNodes));

[componentBinding.js:2]
Added dependency-import "START_COMMENT_REGEX" for macro "childNodes"
OLD:  import {allowedBindings, childNodes, emptyNode, setDomNodeChildren} from '../virtualElements';
NEW:  import {allowedBindings, childNodes, START_COMMENT_REGEX, emptyNode, setDomNodeChildren} from '../virtualElements';

[componentBinding.js:2]
Added dependency-import "_getVirtualChildren" for macro "childNodes"
OLD:  import {allowedBindings, childNodes, START_COMMENT_REGEX, emptyNode, setDomNodeChildren} from '../virtualElements';
NEW:  import {allowedBindings, childNodes, _getVirtualChildren, START_COMMENT_REGEX, emptyNode, setDomNodeChildren} from '../virtualElements';

[componentBinding.js:32]
Inlined: "_isStartComment"  [iteration #2] (global macro)
OLD:  originalChildNodes = Array.from(childNodes(element));
NEW:  originalChildNodes = Array.from((((element.nodeType === 8) && START_COMMENT_REGEX.test(element.nodeValue)) ? _getVirtualChildren(element) : element.childNodes));

Skipped adding dependency import - some import like {START_COMMENT_REGEX} from 'virtualElements' already exists in componentBinding.js


------- src/memoization.js --------

[memoization.js:11]
Found local macro: "parseMemoText"

[memoization.js:46]
Inlined: "parseMemoText"
OLD:  // (!) additional memoText assignment to allow inlining of parseMemoText() call
NEW:  // (!) additional memoText assignment to allow inlining of (.startsWith(MEMO_TEXT_START) ? .substring(9) : null) call

[memoization.js:47]
Inlined: "parseMemoText"
OLD:  if ((memoText = node.nodeValue) && (memoId = parseMemoText(memoText))) {
NEW:  if ((memoText = node.nodeValue) && (memoId = (memoText.startsWith(MEMO_TEXT_START) ? memoText.substring(9) : null))) {


------- src/subscribables/dependencyDetection.js --------

[dependencyDetection.js:12]
Found local macro: "_beginDependencyDetectionWithEmptyFrame"

[dependencyDetection.js:14]
Found local macro: "endDependencyDetection"

[dependencyDetection.js:58]
Found local macro: "_getId"

[dependencyDetection.js:60]
Found local macro: "_runCallback"

[dependencyDetection.js:25]
Inlined: "_beginDependencyDetectionWithEmptyFrame"
OLD:  _beginDependencyDetectionWithEmptyFrame();
NEW:  (currentFrame = void outerFrames.push(currentFrame));

[dependencyDetection.js:32]
Inlined: "endDependencyDetection"
OLD:  endDependencyDetection();
NEW:  (currentFrame = outerFrames.pop());

[dependencyDetection.js:44]
Inlined: "_beginDependencyDetectionWithEmptyFrame"
OLD:  _beginDependencyDetectionWithEmptyFrame();
NEW:  (currentFrame = void outerFrames.push(currentFrame));

[dependencyDetection.js:47]
Inlined: "endDependencyDetection"
OLD:  endDependencyDetection();
NEW:  (currentFrame = outerFrames.pop());

[dependencyDetection.js:65]
Inlined: "_runCallback"
OLD:  export const registerDependencyInternal = (subscribable) => currentFrame && _runCallback(subscribable);
NEW:  export const registerDependencyInternal = (subscribable) => currentFrame && (currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = _getId())));

[dependencyDetection.js:65]
Inlined: "_getId"  [iteration #2]
OLD:  export const registerDependencyInternal = (subscribable) => currentFrame && _runCallback(subscribable);
NEW:  export const registerDependencyInternal = (subscribable) => currentFrame && (currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = (++lastId))));

[dependencyDetection.js:69]
Inlined: "isSubscribable" (global macro)
OLD:  if (!isSubscribable(subscribable)) {
NEW:  if (!(!!(subscribable && subscribable[IS_SUBSCRIBABLE]))) {

[dependencyDetection.js:1]
Added dependency-import "IS_SUBSCRIBABLE" for macro "isSubscribable"
OLD:  import {isSubscribable} from './observableUtils';
NEW:  import {isSubscribable, IS_SUBSCRIBABLE} from './observableUtils';

[dependencyDetection.js:72]
Inlined: "_runCallback"
OLD:  _runCallback(subscribable);
NEW:  (currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = _getId())));

[dependencyDetection.js:72]
Inlined: "_getId"  [iteration #2]
OLD:  _runCallback(subscribable);
NEW:  (currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = (++lastId))));

[dependentObservable.js:75]
Inlined: "initSubscribableInternal" (global macro)
OLD:  initSubscribableInternal(_computedObservable);
NEW:  ((_computedObservable._subscriptions = {change: []}) && (_computedObservable._versionNumber = 1));

[dependentObservable.js:215]
Inlined: "hasSubscribableChanged" (global macro)
OLD:  if ((hasEvalDelayed && depTarget._notificationIsPending) || hasSubscribableChanged(depTarget, dependency._version)) {
NEW:  if ((hasEvalDelayed && depTarget._notificationIsPending) || (depTarget.getVersion() !== dependency._version)) {

[dependentObservable.js:352]
Inlined: "updateSubscribableVersion" (global macro)
OLD:  updateSubscribableVersion(computedObservable);
NEW:  (computedObservable._versionNumber++);

[dependentObservable.js:479]
Inlined: "updateSubscribableVersion" (global macro)
OLD:  updateSubscribableVersion(computedObservable);
NEW:  (computedObservable._versionNumber++);

[dependentObservable.js:504]
Inlined: "updateSubscribableVersion" (global macro)
OLD:  updateSubscribableVersion(computedObservable);
NEW:  (computedObservable._versionNumber++);

[dependentObservable.js:517]
Inlined: "hasSubscriptionsForEvent" (global macro)
OLD:  if (!state.isDisposed && event === 'change' && !hasSubscriptionsForEvent(this, 'change')) {
NEW:  if (!state.isDisposed && event === 'change' && !((this._subscriptions['change'] || 0).length)) {


------- src/subscribables/observable.js --------

[observable.js:60]
Found global macro: "peekObservableInternal"
Dependencies (to auto-import): LATEST_VALUE_KEY

[observable.js:63]
Found global macro: "observableValueWillMutateInternal"
Dependencies (to auto-import): LATEST_VALUE_KEY

[observable.js:28]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(_self);
NEW:  (_self.notifySubscribers(_self[LATEST_VALUE_KEY], 'beforeChange'));

[observable.js:43]
Inlined: "initSubscribableInternal" (global macro)
OLD:  initSubscribableInternal(_observable);
NEW:  ((_observable._subscriptions = {change: []}) && (_observable._versionNumber = 1));

[observable.js:70]
Inlined: "peekObservableInternal" (global macro)
OLD:  return peekObservableInternal(this);
NEW:  return (this[LATEST_VALUE_KEY]);

[observable.js:78]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

[observableArray.changeTracking.js:42]
Inlined: "hasSubscriptionsForEvent" (global macro)
OLD:  if (event === ARRAY_CHANGE_EVENT_NAME && !hasSubscriptionsForEvent(target, ARRAY_CHANGE_EVENT_NAME)) {
NEW:  if (event === ARRAY_CHANGE_EVENT_NAME && !((target._subscriptions[ARRAY_CHANGE_EVENT_NAME] || 0).length)) {

[observableArray.changeTracking.js:82]
Inlined: "hasSubscriptionsForEvent" (global macro)
OLD:  if (hasSubscriptionsForEvent(target, ARRAY_CHANGE_EVENT_NAME)) {
NEW:  if (((target._subscriptions[ARRAY_CHANGE_EVENT_NAME] || 0).length)) {


------- src/subscribables/observableArray.js --------

[observableArray.js:21]
Found local macro: "_getItemFilterPredicate"  (MULTI-LINE-EXPRESSION)

[observableArray.js:28]
Inlined: "peekObservableInternal" (global macro)
OLD:  let underlyingArray = peekObservableInternal(this),
NEW:  let underlyingArray = (this[LATEST_VALUE_KEY]),

[observableArray.js:1]
Added dependency-import "LATEST_VALUE_KEY" for macro "peekObservableInternal"
OLD:  import {observable, OBSERVABLE_PROTOTYPE, observableValueWillMutateInternal, peekObservableInternal} from './observable';
NEW:  import {observable, OBSERVABLE_PROTOTYPE, observableValueWillMutateInternal, peekObservableInternal, LATEST_VALUE_KEY} from './observable';

[observableArray.js:31]
Inlined: "_getItemFilterPredicate"
OLD:  predicate = _getItemFilterPredicate(valueOrPredicate);
NEW:  predicate = ( (typeof valueOrPredicate === 'function' && !valueOrPredicate[IS_OBSERVABLE]) ? valueOrPredicate : (value) => value === valueOrPredicate);

[observableArray.js:37]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:56]
Inlined: "peekObservableInternal" (global macro)
OLD:  let underlyingArray = peekObservableInternal(this),
NEW:  let underlyingArray = (this[LATEST_VALUE_KEY]),

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:59]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:69]
Inlined: "peekObservableInternal" (global macro)
OLD:  let underlyingArray = peekObservableInternal(this),
NEW:  let underlyingArray = (this[LATEST_VALUE_KEY]),

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:70]
Inlined: "_getItemFilterPredicate"
OLD:  predicate = _getItemFilterPredicate(valueOrPredicate);
NEW:  predicate = ( (typeof valueOrPredicate === 'function' && !valueOrPredicate[IS_OBSERVABLE]) ? valueOrPredicate : (value) => value === valueOrPredicate);

[observableArray.js:72]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:98]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:132]
Inlined: "peekObservableInternal" (global macro)
OLD:  let underlyingArray = peekObservableInternal(this);
NEW:  let underlyingArray = (this[LATEST_VALUE_KEY]);

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js

[observableArray.js:133]
Inlined: "observableValueWillMutateInternal" (global macro)
OLD:  observableValueWillMutateInternal(this);
NEW:  (this.notifySubscribers(this[LATEST_VALUE_KEY], 'beforeChange'));

Skipped adding dependency import - some import like {LATEST_VALUE_KEY} from 'observable' already exists in observableArray.js


------- src/subscribables/observableUtils.js --------

[observableUtils.js:2]
Found global macro: "isSubscribable"
Dependencies (to auto-import): IS_SUBSCRIBABLE


------- src/subscribables/subscribable.js --------

[subscribable.js:20]
Found global macro: "updateSubscribableVersion"

[subscribable.js:22]
Found global macro: "hasSubscriptionsForEvent"

[subscribable.js:28]
Found global macro: "hasSubscribableChanged"

[subscribable.js:35]
Found global macro: "initSubscribableInternal"

[subscribable.js:41]
Inlined: "initSubscribableInternal" (global macro)
OLD:  initSubscribableInternal(instance);
NEW:  ((instance._subscriptions = {change: []}) && (instance._versionNumber = 1));

[subscribable.js:73]
Inlined: "updateSubscribableVersion" (global macro)
OLD:  updateSubscribableVersion(this);
NEW:  (this._versionNumber++);

[subscribable.js:75]
Inlined: "hasSubscriptionsForEvent" (global macro)
OLD:  if (!hasSubscriptionsForEvent(this, event)) {
NEW:  if (!((this._subscriptions[event] || 0).length)) {

[subscribable.js:104]
Inlined: "hasSubscribableChanged" (global macro)
OLD:  return hasSubscribableChanged(this, versionToCheck);
NEW:  return (this.getVersion() !== versionToCheck);

[subscribable.js:197]
Inlined: "initSubscribableInternal" (global macro)
OLD:  initSubscribableInternal(this);
NEW:  ((this._subscriptions = {change: []}) && (this._versionNumber = 1));


------- src/templating/templateSources.js --------

[templateSources.js:42]
Found local macro: "_getTemplateDomData"

[templateSources.js:74]
Inlined: "getDomData" (global macro)
OLD:  return getDomData(this.domElement, DOM_DATA_KEY_PREFIX + key);
NEW:  return (this.domElement[DOM_DATASTORE_PROP] && this.domElement[DOM_DATASTORE_PROP][DOM_DATA_KEY_PREFIX + key]);

[templateSources.js:1]
Added dependency-import "DOM_DATASTORE_PROP" for macro "getDomData"
OLD:  import {getDomData, setDomData, nextDomDataKey} from '../utils.domData';
NEW:  import {getDomData, DOM_DATASTORE_PROP, setDomData, nextDomDataKey} from '../utils.domData';

[templateSources.js:82]
Inlined: "_getTemplateDomData"
OLD:  let templateData = _getTemplateDomData(element),
NEW:  let templateData = (getDomData(element, TEMPLATES_DOM_DATA_KEY) || {}),

[templateSources.js:82]
Inlined: "getDomData" (global macro)
OLD:  let templateData = _getTemplateDomData(element),
NEW:  let templateData = ((element[DOM_DATASTORE_PROP] && element[DOM_DATASTORE_PROP][TEMPLATES_DOM_DATA_KEY]) || {}),

Skipped adding dependency import - some import like {DOM_DATASTORE_PROP} from 'utils.domData' already exists in templateSources.js

[templateSources.js:123]
Inlined: "_getTemplateDomData"
OLD:  let templateData = _getTemplateDomData(this.domElement);
NEW:  let templateData = (getDomData(this.domElement, TEMPLATES_DOM_DATA_KEY) || {});

[templateSources.js:123]
Inlined: "getDomData" (global macro)
OLD:  let templateData = _getTemplateDomData(this.domElement);
NEW:  let templateData = ((this.domElement[DOM_DATASTORE_PROP] && this.domElement[DOM_DATASTORE_PROP][TEMPLATES_DOM_DATA_KEY]) || {});

Skipped adding dependency import - some import like {DOM_DATASTORE_PROP} from 'utils.domData' already exists in templateSources.js


------- src/templating/templating.js --------

[templating.js:106]
Found local macro: "_getFirstNodeFromPossibleArray"

[templating.js:153]
Found local macro: "_resolveTemplateName"  (MULTI-LINE-EXPRESSION)

[templating.js:110]
Inlined: "_getFirstNodeFromPossibleArray"
OLD:  let firstTargetNode = targetNodeOrNodeArray && _getFirstNodeFromPossibleArray(targetNodeOrNodeArray),
NEW:  let firstTargetNode = targetNodeOrNodeArray && (targetNodeOrNodeArray.nodeType ? targetNodeOrNodeArray : targetNodeOrNodeArray.length ? targetNodeOrNodeArray[0] : null),

[templating.js:164]
Inlined: "_getFirstNodeFromPossibleArray"
OLD:  let firstTargetNode = _getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
NEW:  let firstTargetNode = (targetNodeOrNodeArray.nodeType ? targetNodeOrNodeArray : targetNodeOrNodeArray.length ? targetNodeOrNodeArray[0] : null);

[templating.js:173]
Inlined: "_resolveTemplateName"
OLD:  let templateName = _resolveTemplateName(template, bindingContext['$data'], bindingContext),
NEW:  let templateName = ( isObservable(template) ? template() : (typeof template === 'function') ? template(bindingContext['$data'], bindingContext) : template),

[templating.js:178]
Inlined: "_getFirstNodeFromPossibleArray"
OLD:  firstTargetNode = _getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
NEW:  firstTargetNode = (targetNodeOrNodeArray.nodeType ? targetNodeOrNodeArray : targetNodeOrNodeArray.length ? targetNodeOrNodeArray[0] : null);

[templating.js:209]
Inlined: "_resolveTemplateName"
OLD:  let templateName = _resolveTemplateName(template, arrayValue, arrayItemContext);
NEW:  let templateName = ( isObservable(template) ? template() : (typeof template === 'function') ? template(arrayValue, arrayItemContext) : template);

[templating.js:235]
Inlined: "peekObservableInternal" (global macro)
OLD:  _setDomNodeChildrenFromArrayMappingIgnoringUnwrapped(peekObservableInternal(arrayOrObservableArray));
NEW:  _setDomNodeChildrenFromArrayMappingIgnoringUnwrapped((arrayOrObservableArray[LATEST_VALUE_KEY]));

[templating.js:19]
Added dependency-import "LATEST_VALUE_KEY" for macro "peekObservableInternal"
OLD:  import {peekObservableInternal} from '../subscribables/observable.js';
NEW:  import {peekObservableInternal, LATEST_VALUE_KEY} from '../subscribables/observable.js';

[templating.js:261]
Inlined: "getDomData" (global macro)
OLD:  let oldComputed = getDomData(element, TEMPLATE_COMPUTED_DOM_DATA_KEY);
NEW:  let oldComputed = (element[DOM_DATASTORE_PROP] && element[DOM_DATASTORE_PROP][TEMPLATE_COMPUTED_DOM_DATA_KEY]);

[templating.js:10]
Added dependency-import "DOM_DATASTORE_PROP" for macro "getDomData"
OLD:  import {getDomData, setDomData, nextDomDataKey} from '../utils.domData';
NEW:  import {getDomData, DOM_DATASTORE_PROP, setDomData, nextDomDataKey} from '../utils.domData';

[templating.js:290]
Inlined: "getDomData" (global macro)
OLD:  if (!container || !getDomData(container, CLEAN_CONTAINER_DOM_DATA_KEY)) {
NEW:  if (!container || !(container[DOM_DATASTORE_PROP] && container[DOM_DATASTORE_PROP][CLEAN_CONTAINER_DOM_DATA_KEY])) {

Skipped adding dependency import - some import like {DOM_DATASTORE_PROP} from 'utils.domData' already exists in templating.js

[templating.js:298]
Inlined: "childNodes" (global macro)
OLD:  let templateNodes = childNodes(element);
NEW:  let templateNodes = (_isStartComment(element) ? _getVirtualChildren(element) : element.childNodes);

[templating.js:1]
Added dependency-import "START_COMMENT_REGEX" for macro "childNodes"
OLD:  import {nextSibling, setDomNodeChildren, emptyNode, childNodes, allowedBindings} from '../virtualElements';
NEW:  import {nextSibling, setDomNodeChildren, emptyNode, childNodes, START_COMMENT_REGEX, allowedBindings} from '../virtualElements';

[templating.js:1]
Added dependency-import "_getVirtualChildren" for macro "childNodes"
OLD:  import {nextSibling, setDomNodeChildren, emptyNode, childNodes, START_COMMENT_REGEX, allowedBindings} from '../virtualElements';
NEW:  import {nextSibling, setDomNodeChildren, emptyNode, childNodes, _getVirtualChildren, START_COMMENT_REGEX, allowedBindings} from '../virtualElements';

[templating.js:298]
Inlined: "_isStartComment"  [iteration #2] (global macro)
OLD:  let templateNodes = childNodes(element);
NEW:  let templateNodes = (((element.nodeType === 8) && START_COMMENT_REGEX.test(element.nodeValue)) ? _getVirtualChildren(element) : element.childNodes);

Skipped adding dependency import - some import like {START_COMMENT_REGEX} from 'virtualElements' already exists in templating.js


------- src/utils.domData.js --------

[utils.domData.js:9]
Found global macro: "getDomData"
Dependencies (to auto-import): DOM_DATASTORE_PROP


------- src/utils.domNodeDisposal.js --------

[utils.domNodeDisposal.js:9]
Found local macro: "_isNodeTypeCleanable"

[utils.domNodeDisposal.js:10]
Found local macro: "_isNodeTypeCleanableWithDescendents"

[utils.domNodeDisposal.js:126]
Found global macro: "removeNode"
Dependencies (to auto-import): cleanNode

[utils.domNodeDisposal.js:37]
Inlined: "_isNodeTypeCleanableWithDescendents"
OLD:  if (_isNodeTypeCleanableWithDescendents(node.nodeType)) {
NEW:  if ((node.nodeType === 1 || node.nodeType === 9)) {

[utils.domNodeDisposal.js:110]
Inlined: "_isNodeTypeCleanable"
OLD:  if (_isNodeTypeCleanable(node.nodeType)) {
NEW:  if ((node.nodeType === 1 || node.nodeType === 8 || node.nodeType === 9)) {

[utils.domNodeDisposal.js:115]
Inlined: "_isNodeTypeCleanableWithDescendents"
OLD:  if (_isNodeTypeCleanableWithDescendents(node.nodeType)) {
NEW:  if ((node.nodeType === 1 || node.nodeType === 9)) {

[utils.domNodes.js:6]
Inlined: "removeNode" (global macro)
OLD:  removeNode(child);
NEW:  (cleanNode(child).remove());

[utils.domNodes.js:1]
Added dependency-import "cleanNode" for macro "removeNode"
OLD:  import {removeNode} from './utils.domNodeDisposal';
NEW:  import {removeNode, cleanNode} from './utils.domNodeDisposal';

[utils.js:200]
Inlined: "removeNode" (global macro)
OLD:  removeNode(nodesToReplaceArray[i]);
NEW:  (cleanNode(nodesToReplaceArray[i]).remove());

Skipped adding macro-dependency cleanNode (already imported)


------- src/virtualElements.js --------

[virtualElements.js:19]
Found global macro: "_isStartComment"
Dependencies (to auto-import): START_COMMENT_REGEX

[virtualElements.js:20]
Found global macro: "_isEndComment"
Dependencies (to auto-import): END_COMMENT_REGEX

[virtualElements.js:56]
Found global macro: "childNodes"
Dependencies (to auto-import): START_COMMENT_REGEX, _getVirtualChildren

[virtualElements.js:29]
Inlined: "_isEndComment" (global macro)
OLD:  if (_isEndComment(currentNode)) {
NEW:  if (((currentNode.nodeType === 8) && END_COMMENT_REGEX.test(currentNode.nodeValue))) {

[virtualElements.js:36]
Inlined: "_isStartComment" (global macro)
OLD:  if (_isStartComment(currentNode)) {
NEW:  if (((currentNode.nodeType === 8) && START_COMMENT_REGEX.test(currentNode.nodeValue))) {

[virtualElements.js:59]
Inlined: "_isStartComment" (global macro)
OLD:  if (!_isStartComment(node)) {
NEW:  if (!((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue))) {

[virtualElements.js:63]
Inlined: "childNodes" (global macro)
OLD:  let virtualChildren = childNodes(node);
NEW:  let virtualChildren = (_isStartComment(node) ? _getVirtualChildren(node) : node.childNodes);

[virtualElements.js:63]
Inlined: "_isStartComment"  [iteration #2] (global macro)
OLD:  let virtualChildren = childNodes(node);
NEW:  let virtualChildren = (((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue)) ? _getVirtualChildren(node) : node.childNodes);

[virtualElements.js:65]
Inlined: "removeNode" (global macro)
OLD:  removeNode(virtualChildren[i]);
NEW:  (cleanNode(virtualChildren[i]).remove());

[virtualElements.js:9]
Added dependency-import "cleanNode" for macro "removeNode"
OLD:  import {removeNode} from './utils.domNodeDisposal';
NEW:  import {removeNode, cleanNode} from './utils.domNodeDisposal';

[virtualElements.js:70]
Inlined: "_isStartComment" (global macro)
OLD:  if (!_isStartComment(node)) {
NEW:  if (!((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue))) {

[virtualElements.js:84]
Inlined: "_isStartComment" (global macro)
OLD:  if (_isStartComment(containerNode)) {
NEW:  if (((containerNode.nodeType === 8) && START_COMMENT_REGEX.test(containerNode.nodeValue))) {

[virtualElements.js:107]
Inlined: "_isStartComment" (global macro)
OLD:  if (_isStartComment(containerNode)) {
NEW:  if (((containerNode.nodeType === 8) && START_COMMENT_REGEX.test(containerNode.nodeValue))) {

[virtualElements.js:119]
Inlined: "_isStartComment" (global macro)
OLD:  if (!_isStartComment(node)) {
NEW:  if (!((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue))) {

[virtualElements.js:121]
Inlined: "_isEndComment" (global macro)
OLD:  if (_nodeFirstChild && _isEndComment(_nodeFirstChild)) {
NEW:  if (_nodeFirstChild && ((_nodeFirstChild.nodeType === 8) && END_COMMENT_REGEX.test(_nodeFirstChild.nodeValue))) {

[virtualElements.js:127]
Inlined: "_isEndComment" (global macro)
OLD:  if (!_nodeNextSibling|| _isEndComment(_nodeNextSibling)) {
NEW:  if (!_nodeNextSibling|| ((_nodeNextSibling.nodeType === 8) && END_COMMENT_REGEX.test(_nodeNextSibling.nodeValue))) {

[virtualElements.js:134]
Inlined: "_isStartComment" (global macro)
OLD:  if (_isStartComment(node)) {
NEW:  if (((node.nodeType === 8) && START_COMMENT_REGEX.test(node.nodeValue))) {

[virtualElements.js:138]
Inlined: "_isEndComment" (global macro)
OLD:  if (_nodeNextSibling && _isEndComment(_nodeNextSibling)) {
NEW:  if (_nodeNextSibling && ((_nodeNextSibling.nodeType === 8) && END_COMMENT_REGEX.test(_nodeNextSibling.nodeValue))) {


Global macros inlining summary:
 7x  getDomData  - [src/utils.domData.js:9]
 4x  removeNode  - [src/utils.domNodeDisposal.js:126]
 12x  _isStartComment  - [src/virtualElements.js:19]
 4x  _isEndComment  - [src/virtualElements.js:20]
 5x  childNodes  - [src/virtualElements.js:56]
 7x  peekObservableInternal  - [src/subscribables/observable.js:60]
 7x  observableValueWillMutateInternal  - [src/subscribables/observable.js:63]
 1x  isSubscribable  - [src/subscribables/observableUtils.js:2]
 4x  updateSubscribableVersion  - [src/subscribables/subscribable.js:20]
 5x  hasSubscriptionsForEvent  - [src/subscribables/subscribable.js:22]
 2x  hasSubscribableChanged  - [src/subscribables/subscribable.js:28]
 4x  initSubscribableInternal  - [src/subscribables/subscribable.js:35]

Local macros inlining summary:
 4x  _getBindingInfoForNode  - [src/binding/bindingAttributeSyntax.js:37]
 4x  _ensureNodeHasDomData  - [src/binding/bindingAttributeSyntax.js:38]
 3x  _getOrAddBindingInfoInDomData  - [src/binding/bindingAttributeSyntax.js:39]
 4x  _getBindingContext  - [src/binding/bindingAttributeSyntax.js:549]
 2x  virtualNodeBindingValue  - [src/binding/bindingProvider.js:7]
 2x  _getBindingsString  - [src/binding/bindingProvider.js:16]
 2x  parseMemoText  - [src/memoization.js:11]
 2x  _beginDependencyDetectionWithEmptyFrame  - [src/subscribables/dependencyDetection.js:12]
 2x  endDependencyDetection  - [src/subscribables/dependencyDetection.js:14]
 2x  _getId  - [src/subscribables/dependencyDetection.js:58]
 2x  _runCallback  - [src/subscribables/dependencyDetection.js:60]
 2x  _getItemFilterPredicate  - [src/subscribables/observableArray.js:21]
 2x  _getTemplateDomData  - [src/templating/templateSources.js:42]
 3x  _getFirstNodeFromPossibleArray  - [src/templating/templating.js:106]
 2x  _resolveTemplateName  - [src/templating/templating.js:153]
 1x  _isNodeTypeCleanable  - [src/utils.domNodeDisposal.js:9]
 2x  _isNodeTypeCleanableWithDescendents  - [src/utils.domNodeDisposal.js:10]

=======================================================
Rollup inline-macros plugin finished successfully
Inlined 103 usages of 29 macros (12 global) in 19 files
=======================================================
